% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_samples.R
\name{select_samples}
\alias{select_samples}
\title{Select Samples for Population Genomics Studies}
\usage{
select_samples(
  ranked_meta,
  max_samples_per_cluster = 8,
  min_samples_per_cluster = 4,
  total_budget = NULL,
  cluster_specific_max = NULL,
  protected_clusters = NULL,
  pop_col = "Pop"
)
}
\arguments{
\item{ranked_meta}{A data frame containing ranked metadata (output from \code{rank_samples()}).
Must contain columns: cluster ID column (specified by \code{pop_col}), \code{is_sequenced} (logical),
\code{cluster_rank} (numeric), and \code{SampleID} (unique identifier).}

\item{max_samples_per_cluster}{Integer. Default maximum number of samples to select
per cluster. Default is 8.}

\item{min_samples_per_cluster}{Integer. Minimum number of samples required to keep
a cluster in the final selection. Clusters below this threshold are removed.
Default is 4.}

\item{total_budget}{Integer or NULL. Total number of samples to select across all
clusters. If NULL, no budget constraint is applied. Default is NULL.}

\item{cluster_specific_max}{Named list or NULL. Specify higher (or lower) maximums
for specific clusters. Names should match cluster IDs in the cluster column.
Example: \code{list("Cluster_5" = 10, "Cluster_12" = 10)}. Default is NULL.}

\item{protected_clusters}{Character vector or NULL. Cluster IDs that should not
have samples removed when enforcin budget constraint. Useful when there are specific target populations with higher desired sample sizes. Default is NULL.}

\item{pop_col}{Character string specifying the column name for population/cluster
identification. Default is "Pop".}
}
\value{
A data frame containing the selected samples with all original metadata columns.
}
\description{
This function selects samples from ranked metadata based on cluster constraints,
budget limitations, and optional priority clusters. It ensures sequenced samples
are always included and applies cluster-specific maximums when specified.
}
\details{
The function follows this workflow:
\enumerate{
  \item Always includes all sequenced samples (these are never removed)
  \item Selects unsequenced samples up to cluster-specific or default maximums
  \item Removes clusters that fall below the minimum sample threshold
  \item If total_budget is specified, removes samples from non-protected clusters
        starting with the largest clusters first, removing worst-ranked samples
}
}
\examples{
\dontrun{
# Basic usage (all clusters treated equally)
selected <- select_samples(ranked_meta,
                          max_samples_per_cluster = 8,
                          min_samples_per_cluster = 4,
                          total_budget = 200,
                          pop_col = "Pop")

# With priority clusters
selected <- select_samples(ranked_meta,
                          max_samples_per_cluster = 8,
                          cluster_specific_max = list("Cluster_5" = 10,
                                                     "Cluster_12" = 10),
                          protected_clusters = c("Cluster_5", "Cluster_12"),
                          pop_col = "Pop")
}

}
